# 01. 왜 pytest인가? 올른 도구의 선택

우리가 어떤 문제를 해결할 때, 어떤 도구를 선택하는지는 결과물의 품질과 작업의 즐거움에 큰 영향을 미칩니다. 테스트 역시 마찬가지입니다. 파이썬에는 `unittest`라는 표준 라이브러리에 내장된 테스트 프레임워크가 있지만, 오늘날 대부분의 파이썬 개발자들은 `pytest`를 선택합니다. 그 이유는 `pytest`가 단순히 테스트를 '가능하게' 하는 것을 넘어, 테스트 작성 과정을 '즐겁고 생산적으로' 만들어주기 때문입니다.

이 파트에서는 `pytest`가 현대 파이썬 개발에서 사실상의 표준인 이유를 설명하고, 개발자 친화적인 설계가 어떻게 팀의 학습 곡선을 가속화하고 테스트 문화를 성공적으로 정착시키는지에 대해 깊이 있게 알아봅니다.

### `pytest`의 압도적인 장점들

#### 1. 최소한의 코드로, 최대한의 명확성을 (직접 비교해보기)

`pytest`의 가장 큰 철학적 차이는 파이썬의 기본 `assert` 문을 그대로 사용한다는 점입니다. 이는 테스트 코드를 놀랍도록 간결하고 직관적으로 만듭니다.

`unittest`에서는 `self.assertEqual()`, `self.assertTrue()`, `self.assertIn()` 등 수많은 `assert` 관련 메서드를 외워서 사용해야 하고, 정해진 클래스 구조를 따라야 합니다. 반면, `pytest`에서는 그저 평범한 파이썬 함수와 `assert` 하나면 충분합니다.

백문이 불여일견입니다. 바로 아래 `examples` 폴더에 있는 두 파일을 직접 비교해 보세요. 두 파일은 완전히 동일한 내용을 테스트하고 있습니다.

-   **`examples/test_unittest_example.py`**:
    ```python
    import unittest

    class TestMathFunctions(unittest.TestCase):
        def test_add(self):
            self.assertEqual(2 + 3, 5)

        def test_subtract(self):
            self.assertEqual(10 - 5, 5)
    ```

-   **`examples/test_pytest_example.py`**:
    ```python
    def test_add():
        assert 2 + 3 == 5

    def test_subtract():
        assert 10 - 5 == 5
    ```

`pytest`의 코드가 훨씬 더 파이썬스럽고(Pythonic) 읽기 쉽다는 것을 바로 알 수 있습니다. 이는 테스트를 작성하는 심리적 장벽을 크게 낮추어, 개발자들이 더 적극적으로 테스트를 작성하도록 유도합니다.

#### 2. 강력하고 유연한 Fixture 기능

테스트를 작성하다 보면, 테스트 실행 전에 무언가를 '준비'하고 실행 후에 '정리'해야 하는 경우가 많습니다 (예: 데이터베이스 연결, 임시 파일 생성). `unittest`는 이를 `setUp`과 `tearDown` 메서드로 처리하지만, `pytest`의 **Fixture**는 이를 훨씬 더 유연하고 강력하며 재사용 가능하게 만듭니다. (Fixture에 대한 자세한 내용은 Part 3에서 다룹니다.)

#### 3. 거대한 생태계와 무한한 확장성

`pytest`는 수많은 플러그인을 통해 기능을 무한하게 확장할 수 있습니다.
-   `pytest-cov`: 테스트 코드 커버리지를 측정합니다.
-   `pytest-mock`: 외부 의존성을 쉽게 가짜 객체(Mock)로 대체할 수 있게 해줍니다.
-   `pytest-xdist`: 여러 CPU 코어를 사용하여 테스트를 병렬로 실행하여 시간을 단축합니다.
-   `pytest-django`, `pytest-flask`: 각 웹 프레임워크에 특화된 테스트 기능을 제공합니다.

이처럼 강력한 생태계 덕분에, 우리는 어떤 복잡한 테스트 요구사항이 생겨도 밑바닥부터 구현할 필요 없이 잘 만들어진 플러그인을 가져다 쓰면 됩니다.

### 도구의 선택이 문화에 미치는 영향

도구의 선택은 단순히 기술적인 결정을 넘어, 팀의 개발 문화에까지 영향을 미칩니다. `unittest`의 다소 형식적이고 장황한 구조는 테스트 작성을 '해야만 하는 귀찮은 일'로 느끼게 만들 수 있습니다.

반면, `pytest`의 간결하고 함수 중심적인 접근 방식은 테스트 작성을 코딩의 자연스러운 일부로 받아들이게 합니다. 진입 장벽이 낮다는 것은 더 많은 테스트가 작성된다는 의미이며, 이는 버그 없는 고품질의 코드를 만들고자 하는 조직의 목표를 더 빠르게 달성하게 만드는 핵심 촉매제가 됩니다.

이제 왜 `pytest`를 배워야 하는지 충분히 공감하셨을 겁니다. 다음 세션에서는 실제로 `pytest`를 사용하여 우리의 첫 번째 테스트를 작성해보겠습니다.

---
**다음 세션**: [02. 첫 번째 테스트 작성하기](../02-first-test/README.md)
