# 03. 신호 읽기: pytest 결과 심층 분석

테스트를 실행하는 것만큼이나 그 결과를 정확하게 해석하는 것이 중요합니다. `pytest`가 제공하는 피드백은 단순한 성공/실패 표시가 아니라, 코드의 문제를 정확히 알려주는 매우 유용한 진단서입니다. 실패한 테스트는 좌절의 대상이 아니라, 버그를 수정하고 코드를 개선하기 위한 가장 확실한 단서입니다.

### `pytest`의 다양한 결과 신호들

`pytest`를 실행하면 각 테스트의 결과가 한 글자의 코드로 표시됩니다. 각 신호의 의미를 정확히 이해해 봅시다.

-   `.` (점) - **통과 (PASSED)**: 테스트 함수 내의 모든 `assert` 문이 참(True)으로 평가되었습니다. 코드가 우리가 기대한 대로 정확하게 작동하고 있다는 의미입니다.

-   `F` - **실패 (FAILED)**: 테스트는 정상적으로 실행되었지만, `assert` 문 중 하나가 거짓(False)으로 평가되었습니다. 이는 코드의 '로직'에 버그가 있음을 의미합니다. 즉, 기능은 작동했지만 결과가 틀렸습니다.

-   `E` - **오류 (ERROR)**: `assert` 문에 도달하기도 전에, 테스트를 실행하는 도중 얘기치 않은 예외(Exception)가 발생했습니다. 이는 보통 코드의 로직 문제라기보다는 `TypeError`, `NameError`와 같은 프로그래밍 실수나, 설정 오류, 외부 자원(파일, 네트워크) 접근 실패 등 예상치 못한 상황으로 인해 발생합니다.

-   `s` - **건너뜀 (SKIPPED)**: 개발자가 의도적으로 특정 테스트를 실행에서 제외했을 때 표시됩니다. (예: 아직 구현되지 않은 기능)

-   `x` - **예상된 실패 (XFAIL)**: "이 테스트는 현재 버그로 인해 실패할 것으로 예상된다"고 미리 표시해 둔 테스트가 실제로 실패했을 때 나타납니다. 예상대로 실패했으므로 전체 테스트는 중단되지 않습니다.

### 실습: 실패(`F`)와 오류(`E`) 직접 마주하기

이론만으로는 부족합니다. 직접 실패와 오류를 경험하고 `pytest`의 리포트를 분석해봅시다. 이번 실습은 이전 세션에서 만든 `my-first-test` 폴더를 그대로 사용하거나, 새로 만드셔도 좋습니다.

**1. 실습 파일 준비**

`my-first-test` 폴더(또는 새로 만든 폴더) 안에, 이 세션의 `examples` 폴더에 있는 두 파일(`math_functions.py`, `test_math_issues.py`)의 내용을 참고하여 동일한 파일들을 생성하거나 수정해주세요.

-   `math_functions.py` 에는 `divide` 함수를 추가합니다.
-   기존 `test_math.py` 파일의 이름은 `test_math_issues.py`로 바꾸고, 내용을 아래와 같이 수정합니다.

**`math_functions.py`**
```python
def add(a, b):
    return a + b

def divide(a, b):
    if b == 0:
        raise ValueError("0으로 나눌 수 없습니다.")
    return a / b
```

**`test_math_issues.py`**
```python
from math_functions import add, divide

def test_add_failure():
    assert add(2, 2) == 5

def test_divide_error():
    divide(10, 0)
```

**2. 테스트 실행**

터미널에서 `uv run pytest`를 실행하면, 1개의 `실패(F)`와 1개의 `오류(E)`가 발생하는 것을 볼 수 있습니다. 이제 그 아래 출력되는 상세 리포트를 분석해봅시다.

### 실패(`F`) 분석: 무엇이, 왜 틀렸는가?

`test_add_failure` 테스트에 대한 리포트는 다음과 유사하게 보일 것입니다.

```
________________________________ test_add_failure ________________________________
...
>       assert add(2, 2) == 5
E       assert 4 == 5
...
=========================== short test summary info ============================
FAILED test_math_issues.py::test_add_failure - assert 4 == 5
```

`pytest`의 실패 보고서는 놀랍도록 친절합니다.
1.  **어떤 테스트?**: `test_math_issues.py` 파일의 `test_add_failure` 함수.
2.  **어떤 코드?**: `assert add(2, 2) == 5` 라인.
3.  **왜 실패?**: `assert` 문의 왼쪽(`add(2,2)`의 결과)은 `4`였는데, 오른쪽의 기대값은 `5`였다. `4`는 `5`와 다르므로 실패했다.

이 정보만으로도 우리는 버그의 위치와 원인을 거의 즉시 파악하고 수정할 수 있습니다.

### 오류(`E`) 분석: 예상치 못한 재앙

`test_divide_error` 테스트에 대한 리포트는 실패 리포트와는 사뭇 다릅니다.

```
_________________________ ERROR in test_divide_error _________________________
...
    def test_divide_error():
>       divide(10, 0)

math_functions.py:8: in divide
    raise ValueError("0으로 나눌 수 없습니다.")
E   ValueError: 0으로 나눌 수 없습니다.
...
=========================== short test summary info ============================
ERROR test_math_issues.py::test_divide_error
```

`오류(E)` 보고서는 `assert` 비교 결과가 아니라, **어떤 코드 라인**(`divide(10, 0)`)에서 시작하여 최종적으로 **어떤 예외**(`ValueError`)가 발생했는지 그 과정을 역추적해서 보여줍니다 (이를 '트레이스백'이라 합니다).

이를 통해 우리는 코드의 로직이 틀린 것이 아니라, 예외적인 상황(`0으로 나누기`)이 발생하여 테스트 자체가 비정상적으로 중단되었음을 알 수 있습니다.

이처럼 `pytest`의 상세한 결과 리포트를 잘 해석하는 능력은, 버그를 신속하게 해결하고 코드의 안정성을 높이는 데 매우 중요한 기술입니다.

---
**다음 파트**: [Part 3. '어떻게' 할 것인가: pytest 핵심 기능 마스터하기](../../03-pytest-core-features/01-fixtures/README.md)
