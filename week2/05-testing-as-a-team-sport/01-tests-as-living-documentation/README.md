# 01. 살아있는 문서로서의 테스트

소프트웨어 프로젝트에서 문서는 필수적이지만, 가장 큰 문제점은 코드가 변경될 때 문서는 잊히기 쉽다는 것입니다. 결국 문서는 실제 코드의 동작과 달라져 신뢰를 잃고 아무도 읽지 않게 됩니다.

하지만 **잘 작성된 테스트 코드는 절대로 거짓말을 하지 않는 '살아있는 문서(Living Documentation)'**가 됩니다. 테스트가 통과한다는 것 자체가 현재 시스템이 어떻게 동작하는지에 대한 가장 정확하고 최신의 명세(specification)임을 보장하기 때문입니다.

### 왜 테스트가 최고의 문서인가?

-   **정확성**: 테스트는 코드를 직접 실행하여 검증합니다. 만약 시스템의 동작이 바뀌었는데 테스트를 수정하지 않는다면, 테스트는 실패할 것이고 우리는 변경 사실을 즉시 알게 됩니다. 이는 문서가 실제와 달라지는 것을 원천적으로 방지합니다.
-   **구체적인 예시**: "사용자 아이디로 프로필을 조회할 수 있다"라는 추상적인 문장보다, `test_get_user_profile_with_valid_id()`와 같은 테스트 함수는 실제 어떤 값을 입력했을 때 어떤 구조의 결과가 반환되는지 명확한 예시를 보여줍니다.
-   **유지보수성**: 새로운 팀원이 복잡한 비즈니스 로직을 담고 있는 함수를 이해해야 할 때, 낡은 문서를 읽는 것보다 해당 함수에 대한 테스트 코드를 읽는 것이 훨씬 빠르고 정확합니다. 테스트는 그 코드가 만들어진 '의도'와 다양한 '엣지 케이스'들을 가장 잘 설명해줍니다.

### 좋은 테스트 문서의 조건

테스트가 문서의 역할을 제대로 하려면, 단순히 기능 검증을 넘어 '읽는 사람'을 고려하여 작성해야 합니다.

1.  **서술적인 테스트 함수 이름**: `test_1()`과 같은 이름이 아니라, `test_login_with_invalid_password_should_fail()`처럼 테스트의 '시나리오'나 '의도'가 이름에 명확히 드러나야 합니다.
2.  **'Arrange-Act-Assert' 패턴의 명확한 구분**:
    ```python
    def test_add_item_to_cart():
        # 준비 (Arrange): 비어있는 장바구니와 상품 하나를 준비한다.
        cart = ShoppingCart()
        item = Product("Apple", 1.50)

        # 실행 (Act): 장바구니에 상품을 추가한다.
        cart.add_item(item)

        # 단언 (Assert): 장바구니에 상품이 1개 있고, 총액이 1.50인지 확인한다.
        assert cart.item_count() == 1
        assert cart.get_total() == 1.50
    ```
    이처럼 주석이나 코드 구조를 통해 준비-실행-검증 단계를 명확히 구분하면, 테스트를 읽는 것만으로 해당 기능의 사용법과 동작 방식을 쉽게 파악할 수 있습니다.

테스트를 단순히 버그를 찾는 도구가 아니라, 미래의 나 자신과 동료들을 위한 가장 신뢰할 수 있는 '문서'라고 생각하며 작성하는 순간, 코드의 품질과 팀의 생산성은 한 단계 더 발전하게 될 것입니다.

---
**다음 세션**: [02. 코드 리뷰의 혁신](../02-improving-code-reviews/README.md)
